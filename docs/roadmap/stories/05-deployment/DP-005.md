# DP-005: Logging & Observability

## Metadata
- **Epic**: Deployment
- **Status**: `not-started`
- **Priority**: `medium`
- **Effort**: `M` (1-2 hours)
- **Dependencies**: DP-001

## Context

Implement structured logging and observability for production debugging. Good logging is essential for diagnosing issues in deployed applications.

## Requirements

1. Structured JSON logging for production
2. Request/response logging
3. Game event logging
4. Error tracking with context
5. Log levels configurable via environment

## Acceptance Criteria

- [ ] JSON structured logs in production
- [ ] Human-readable logs in development
- [ ] Request ID tracking across logs
- [ ] Game events logged with context
- [ ] Errors include stack traces
- [ ] Sensitive data redacted
- [ ] Log level configurable via env var
- [ ] Logs visible in Railway dashboard

## Implementation Notes

### Logging Configuration

**backend/logging_config.py** (create):
```python
import logging
import sys
import json
from datetime import datetime
from typing import Any
import uuid
from contextvars import ContextVar

from config import get_settings

# Context variable for request tracking
request_id_var: ContextVar[str] = ContextVar("request_id", default="")


class JSONFormatter(logging.Formatter):
    """JSON formatter for production logs."""

    def format(self, record: logging.LogRecord) -> str:
        log_data = {
            "timestamp": datetime.utcnow().isoformat(),
            "level": record.levelname,
            "logger": record.name,
            "message": record.getMessage(),
            "request_id": request_id_var.get(""),
        }

        # Add extra fields
        if hasattr(record, "game_id"):
            log_data["game_id"] = record.game_id
        if hasattr(record, "player_id"):
            log_data["player_id"] = record.player_id
        if hasattr(record, "action"):
            log_data["action"] = record.action

        # Add exception info
        if record.exc_info:
            log_data["exception"] = self.formatException(record.exc_info)

        return json.dumps(log_data)


class DevFormatter(logging.Formatter):
    """Human-readable formatter for development."""

    def format(self, record: logging.LogRecord) -> str:
        request_id = request_id_var.get("")
        prefix = f"[{request_id[:8]}] " if request_id else ""

        base = f"{record.levelname:8} {prefix}{record.getMessage()}"

        if hasattr(record, "game_id"):
            base += f" [game={record.game_id}]"
        if hasattr(record, "player_id"):
            base += f" [player={record.player_id}]"

        return base


def setup_logging():
    """Configure logging based on environment."""
    settings = get_settings()

    # Remove existing handlers
    root = logging.getLogger()
    root.handlers.clear()

    # Create handler
    handler = logging.StreamHandler(sys.stdout)

    # Choose formatter based on environment
    if settings.is_production:
        handler.setFormatter(JSONFormatter())
    else:
        handler.setFormatter(DevFormatter())

    # Set level
    level = getattr(logging, settings.log_level.upper(), logging.INFO)
    root.setLevel(level)
    root.addHandler(handler)

    # Reduce noise from libraries
    logging.getLogger("uvicorn.access").setLevel(logging.WARNING)
    logging.getLogger("websockets").setLevel(logging.WARNING)

    return root


def get_logger(name: str) -> logging.Logger:
    """Get a logger with the given name."""
    return logging.getLogger(name)
```

### Request Middleware

**backend/middleware.py** (create or update):
```python
import uuid
import time
import logging
from starlette.middleware.base import BaseHTTPMiddleware
from starlette.requests import Request

from logging_config import request_id_var, get_logger

logger = get_logger(__name__)


class RequestLoggingMiddleware(BaseHTTPMiddleware):
    """Log requests and add request ID tracking."""

    async def dispatch(self, request: Request, call_next):
        # Generate request ID
        request_id = str(uuid.uuid4())
        request_id_var.set(request_id)

        # Add to response headers
        start_time = time.time()

        # Log request
        logger.info(
            f"{request.method} {request.url.path}",
            extra={"request_id": request_id}
        )

        try:
            response = await call_next(request)

            # Log response
            duration_ms = (time.time() - start_time) * 1000
            logger.info(
                f"{request.method} {request.url.path} -> {response.status_code} ({duration_ms:.0f}ms)"
            )

            response.headers["X-Request-ID"] = request_id
            return response

        except Exception as e:
            logger.exception(f"Request failed: {e}")
            raise
```

### Game Event Logger

**backend/game_logger.py** (create):
```python
from logging_config import get_logger

logger = get_logger("game")


def log_game_event(
    game_id: str,
    event: str,
    player_id: str = None,
    action: dict = None,
    **extra
):
    """Log a game event with context."""
    logger.info(
        event,
        extra={
            "game_id": game_id,
            "player_id": player_id,
            "action": action,
            **extra
        }
    )


def log_game_created(game_id: str, host_id: str):
    log_game_event(game_id, "Game created", player_id=host_id)


def log_player_joined(game_id: str, player_id: str, player_name: str):
    log_game_event(game_id, f"Player joined: {player_name}", player_id=player_id)


def log_action(game_id: str, player_id: str, action_type: str, action_data: dict):
    log_game_event(
        game_id,
        f"Action: {action_type}",
        player_id=player_id,
        action=action_data
    )


def log_game_ended(game_id: str, winner_id: str, final_scores: dict):
    log_game_event(
        game_id,
        "Game ended",
        player_id=winner_id,
        scores=final_scores
    )
```

### Update main.py

```python
from logging_config import setup_logging
from middleware import RequestLoggingMiddleware

# Setup logging first
setup_logging()

app = FastAPI(...)

# Add middleware
app.add_middleware(RequestLoggingMiddleware)
```

### Environment Variables

Add to `.env.example`:
```env
LOG_LEVEL=INFO  # DEBUG, INFO, WARNING, ERROR
```

## Verification

```bash
# Local development (human-readable)
cd backend
LOG_LEVEL=DEBUG uvicorn main:app --reload

# Make a request
curl http://localhost:8000/health
# Logs show: INFO     [abc12345] GET /health -> 200 (5ms)

# Production simulation (JSON)
ENVIRONMENT=prod LOG_LEVEL=INFO uvicorn main:app
# Logs show: {"timestamp":"...","level":"INFO","message":"GET /health -> 200",...}

# Check Railway logs
railway logs
```

### Sample Log Output

**Development:**
```
INFO     Game created [game=abc123]
INFO     Player joined: Alice [game=abc123] [player=p1]
INFO     Action: place_tile [game=abc123] [player=p1]
DEBUG    Tile placed at (5, 3)
INFO     Game ended [game=abc123] [player=p1]
```

**Production (JSON):**
```json
{"timestamp":"2024-01-15T10:30:00","level":"INFO","logger":"game","message":"Game created","game_id":"abc123","player_id":"host1"}
{"timestamp":"2024-01-15T10:30:05","level":"INFO","logger":"game","message":"Player joined: Alice","game_id":"abc123","player_id":"p1"}
```

## Reference

- [Python Logging Best Practices](https://docs.python.org/3/howto/logging.html)
- [Railway Logging](https://docs.railway.app/develop/logs)
- [Structured Logging](https://www.structlog.org/en/stable/)
