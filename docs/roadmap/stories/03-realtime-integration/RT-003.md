# RT-003: Message Handlers

## Metadata
- **Epic**: Real-time Integration
- **Status**: `complete`
- **Priority**: `critical`
- **Effort**: `M` (1-2 hours)
- **Dependencies**: RT-001, RT-002

## Context

Create message handlers to process incoming WebSocket messages and update the Zustand store. Also create action dispatchers for sending messages to the server.

## Requirements

1. Handle all incoming message types from backend
2. Update store based on message type
3. Dispatch actions to send messages
4. Type-safe message definitions

## Acceptance Criteria

- [ ] Handle `game_state` - full state update
- [ ] Handle `player_state` - private player info
- [ ] Handle `trade_proposal` - incoming trade
- [ ] Handle `trade_response` - trade result
- [ ] Handle `error` - error display
- [ ] Handle `game_over` - final scores
- [ ] Send actions: play_tile, found_chain, buy_stocks, etc.
- [ ] Type definitions for all messages
- [ ] Unit tests for each handler

## Implementation Notes

### File to Create

**frontend/src/lib/messageHandlers.ts**:
```typescript
import { useGameStore } from '../stores/gameStore'
import type { ChainName, Coordinate } from '../types/game'

// Incoming message types
interface GameStateMessage {
  type: 'game_state'
  phase: string
  board: unknown[][]
  players: unknown[]
  chains: unknown[]
  current_player_id: string
  tile_pool: number
}

interface PlayerStateMessage {
  type: 'player_state'
  player_id: string
  tiles: { coordinate: string; playability: string }[]
}

interface TradeProposalMessage {
  type: 'trade_proposal'
  from: string
  offer: unknown
  want: unknown
}

interface ErrorMessage {
  type: 'error'
  message: string
}

interface GameOverMessage {
  type: 'game_over'
  scores: unknown[]
}

type IncomingMessage =
  | GameStateMessage
  | PlayerStateMessage
  | TradeProposalMessage
  | ErrorMessage
  | GameOverMessage

export function handleMessage(message: IncomingMessage): void {
  const store = useGameStore.getState()

  switch (message.type) {
    case 'game_state':
      store.setGameState({
        phase: message.phase as any,
        board: message.board as any,
        players: message.players as any,
        chains: message.chains as any,
        currentPlayerId: message.current_player_id,
        tilePool: message.tile_pool,
      })
      break

    case 'player_state':
      store.setMyState(
        message.tiles.map((t) => ({
          coordinate: t.coordinate as Coordinate,
          playability: t.playability as any,
        })),
        message.player_id
      )
      break

    case 'trade_proposal':
      store.setGameState({
        activeTrade: {
          from: message.from,
          to: store.myPlayerId,
          description: formatTradeDescription(message.offer, message.want),
          status: 'pending',
        },
      })
      break

    case 'error':
      // Toast will be shown via UI
      console.error('Server error:', message.message)
      break

    case 'game_over':
      store.setGameState({
        phase: 'game_over',
        finalScores: message.scores as any,
      })
      break

    default:
      console.warn('Unknown message type:', (message as any).type)
  }
}

function formatTradeDescription(offer: unknown, want: unknown): string {
  // Format trade for display
  return JSON.stringify({ offer, want })
}
```

**frontend/src/lib/gameActions.ts**:
```typescript
import { WebSocketClient } from './websocket'

let wsClient: WebSocketClient | null = null

export function setWebSocketClient(client: WebSocketClient): void {
  wsClient = client
}

function send(data: unknown): void {
  if (!wsClient) {
    console.error('WebSocket client not initialized')
    return
  }
  wsClient.send(data)
}

// Game actions
export const gameActions = {
  joinGame: (name: string) => send({ type: 'join_game', name }),

  startGame: () => send({ type: 'start_game' }),

  addBot: (difficulty: 'easy' | 'medium' | 'hard' = 'medium') =>
    send({ type: 'add_bot', difficulty }),

  playTile: (coordinate: string) =>
    send({ type: 'play_tile', coordinate }),

  foundChain: (chain: ChainName) =>
    send({ type: 'found_chain', chain }),

  chooseSurvivor: (chain: ChainName) =>
    send({ type: 'choose_survivor', chain }),

  disposeStock: (sell: number, trade: number, hold: number) =>
    send({ type: 'dispose_stock', sell, trade, hold }),

  buyStocks: (purchases: { chain: ChainName; quantity: number }[]) =>
    send({ type: 'buy_stocks', purchases }),

  endTurn: () => send({ type: 'end_turn' }),

  proposeTrade: (partnerId: string, offer: unknown, want: unknown) =>
    send({ type: 'propose_trade', partner_id: partnerId, offer, want }),

  respondTrade: (accept: boolean) =>
    send({ type: 'respond_trade', accept }),

  declareEndGame: () => send({ type: 'declare_end_game' }),
}
```

## Actual Implementation

Message handling is integrated into the Zustand store rather than a separate file:

**Message Handlers**: `frontend/src/store/gameStore.ts` - `handleMessage` method
**Type Definitions**: `frontend/src/types/api.ts` - all `WebSocketMessage` types
**Action Sending**: `frontend/src/hooks/useWebSocket.ts` - `sendAction` method

The implementation differs from spec by integrating handlers directly into the store, avoiding global state issues.

## Verification

```bash
npm run test -- --grep "messageHandler"

# Integration with backend
# Start backend, connect, verify state updates
```

## Reference

- [Backend main.py](../../../backend/main.py) - Message types
