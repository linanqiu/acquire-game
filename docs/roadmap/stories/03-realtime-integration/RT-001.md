# RT-001: WebSocket Client

## Metadata
- **Epic**: Real-time Integration
- **Status**: `complete`
- **Priority**: `critical`
- **Effort**: `M` (1-2 hours)
- **Dependencies**: FF-001

## Context

Create a WebSocket client to connect to the FastAPI backend. This is the foundation for all real-time game communication.

## Requirements

1. Connect to WebSocket endpoint
2. Handle connection lifecycle (open, close, error)
3. Send messages to server
4. Receive and parse messages
5. Expose connection status

## Acceptance Criteria

- [ ] Connect to `ws://host/ws/player/{room_code}/{player_id}?token={session_token}`
- [ ] Connection status: connecting, connected, disconnected, error
- [ ] `send()` method sends JSON messages
- [ ] `onMessage` callback receives parsed messages
- [ ] `onClose` callback handles disconnection
- [ ] `onError` callback handles errors
- [ ] Automatic JSON serialization/deserialization
- [ ] Unit tests for message handling

## Implementation Notes

### File to Create

**frontend/src/lib/websocket.ts**:
```typescript
type ConnectionStatus = 'connecting' | 'connected' | 'disconnected' | 'error'

interface WebSocketClientOptions {
  onMessage: (data: unknown) => void
  onStatusChange: (status: ConnectionStatus) => void
  onError?: (error: Event) => void
}

export class WebSocketClient {
  private ws: WebSocket | null = null
  private status: ConnectionStatus = 'disconnected'
  private options: WebSocketClientOptions

  constructor(options: WebSocketClientOptions) {
    this.options = options
  }

  connect(url: string): void {
    if (this.ws) {
      this.ws.close()
    }

    this.setStatus('connecting')
    this.ws = new WebSocket(url)

    this.ws.onopen = () => {
      this.setStatus('connected')
    }

    this.ws.onclose = () => {
      this.setStatus('disconnected')
    }

    this.ws.onerror = (error) => {
      this.setStatus('error')
      this.options.onError?.(error)
    }

    this.ws.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data)
        this.options.onMessage(data)
      } catch (e) {
        console.error('Failed to parse WebSocket message:', e)
      }
    }
  }

  send(data: unknown): void {
    if (this.ws && this.status === 'connected') {
      this.ws.send(JSON.stringify(data))
    } else {
      console.warn('WebSocket not connected, cannot send message')
    }
  }

  disconnect(): void {
    if (this.ws) {
      this.ws.close()
      this.ws = null
    }
  }

  getStatus(): ConnectionStatus {
    return this.status
  }

  private setStatus(status: ConnectionStatus): void {
    this.status = status
    this.options.onStatusChange(status)
  }
}
```

### Usage Example
```typescript
const ws = new WebSocketClient({
  onMessage: (data) => {
    console.log('Received:', data)
  },
  onStatusChange: (status) => {
    console.log('Status:', status)
  },
})

// player_id and session_token come from POST /create or POST /join response
ws.connect('ws://localhost:8000/ws/player/ABCD/player-uuid-here?token=session-token-here')
ws.send({ action: 'place_tile', tile: '3B' })
```

### Backend WebSocket Endpoints
From `backend/main.py`:
- `/ws/player/{room_code}/{player_id}?token={session_token}` - Player WebSocket
- `/ws/host/{room_code}` - Host WebSocket (display-only, no player actions)

### Backend HTTP Endpoints (for joining)
- `POST /create` - Create room, returns `{ room_code, player_id, session_token }`
- `POST /join` - Join room, returns `{ room_code, player_id, session_token }`
- `POST /room/{room_code}/add-bot` - Add bot to room
- `POST /room/{room_code}/start` - Start the game
- `GET /room/{room_code}/state` - Get current room state

## Actual Implementation

Implemented as a React hook instead of a class (better React integration):

**File**: `frontend/src/hooks/useWebSocket.ts`

Key differences from spec:
- Hook-based API using `useRef` for WebSocket instance
- Integrated with Zustand store via `handleMessage`
- Exponential backoff reconnection built-in
- Stable `sendAction` callback returned

The hook is used in `PlayerPage.tsx` and `HostPage.tsx`.

## Verification

```bash
npm run test -- --grep "WebSocket"

# Integration test with backend
cd backend && python -m uvicorn main:app --reload &
npm run dev
# Open browser console, verify connection
```

## Reference

- [Backend main.py](../../../backend/main.py) - WebSocket endpoints
