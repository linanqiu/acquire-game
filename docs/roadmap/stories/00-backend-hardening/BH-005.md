# BH-005: Add Merger Queue Visibility

## Metadata
- **Epic**: Backend Hardening
- **Status**: `not-started`
- **Priority**: `high`
- **Effort**: `S` (30-60 minutes)
- **Dependencies**: BH-001

## Context

During stock disposition in a merger, players take turns deciding what to do with their defunct chain stock. The UI storyboard shows:

```
Disposing LUXOR stock in order:
[ok] ALICE (done)
[..] BOB (current)
[ ] CAROL (waiting)
[ ] YOU (waiting)
```

The backend tracks this queue internally but doesn't broadcast it.

## Requirements

1. Expose merger disposition queue in game state broadcasts
2. Include completion status for each player in queue
3. Show which player is currently deciding

## Acceptance Criteria

- [ ] `get_public_state()` includes `merger_disposition_queue` during STOCK_DISPOSITION phase
- [ ] Queue shows player IDs, names, and completion status
- [ ] Current player in queue is marked
- [ ] Queue only present during merger stock disposition
- [ ] Unit tests for queue visibility

## Implementation Notes

### State Structure

```python
# In get_public_state() during STOCK_DISPOSITION phase
{
    "phase": "stock_disposition",
    "merger_state": {
        "survivor": "American",
        "defunct": "Luxor",
        "disposition_queue": [
            {"player_id": "p1", "name": "Alice", "status": "completed"},
            {"player_id": "p2", "name": "Bob", "status": "current"},
            {"player_id": "p3", "name": "Carol", "status": "waiting"},
            {"player_id": "p4", "name": "Dave", "status": "waiting"},
        ]
    },
    ...
}
```

### Implementation in Game Class

```python
# backend/game/game.py
class Game:
    def _get_merger_state(self) -> dict | None:
        """Get current merger state for broadcasting."""
        if self._phase != GamePhase.STOCK_DISPOSITION:
            return None

        if not self._merger_defunct_queue:
            return None

        current_defunct = self._merger_current_defunct
        survivor = self._merger_survivor

        # Build queue with status
        queue = []
        for i, player_id in enumerate(self._merger_stock_players):
            if i < self._merger_stock_index:
                status = "completed"
            elif i == self._merger_stock_index:
                status = "current"
            else:
                status = "waiting"

            queue.append({
                "player_id": player_id,
                "name": self._players[player_id].name,
                "status": status,
            })

        return {
            "survivor": survivor.value if survivor else None,
            "defunct": current_defunct.value if current_defunct else None,
            "disposition_queue": queue,
        }

    def get_public_state(self) -> dict:
        state = {
            # ... existing fields ...
        }

        merger_state = self._get_merger_state()
        if merger_state:
            state["merger_state"] = merger_state

        return state
```

### Files to Modify

1. `backend/game/game.py` - Add `_get_merger_state()`, update `get_public_state()`
2. `backend/tests/test_mergers.py` - Add tests for queue visibility

## Verification

```bash
cd backend

# Run merger tests
pytest tests/scenarios/test_mergers.py -v
pytest tests/scenarios/test_stock_disposition.py -v

# Run full test suite
pytest -v

# Manual test during a merger
python -c "
from game.game import Game, GamePhase

game = Game()
# ... setup game with merger scenario ...

state = game.get_public_state()
if 'merger_state' in state:
    print('Merger state:')
    print('  Survivor:', state['merger_state']['survivor'])
    print('  Defunct:', state['merger_state']['defunct'])
    print('  Queue:')
    for p in state['merger_state']['disposition_queue']:
        print(f'    {p[\"name\"]}: {p[\"status\"]}')
"
```

## Reference

- [Storyboard - merger disposition](../../docs/ui/storyboard.md)
- [Game merger state tracking](../../backend/game/game.py)
