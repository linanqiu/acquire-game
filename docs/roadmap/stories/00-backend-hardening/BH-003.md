# BH-003: Add Event/Activity Logging

## Metadata
- **Epic**: Backend Hardening
- **Status**: `not-started`
- **Priority**: `high`
- **Effort**: `M` (1-2 hours)
- **Dependencies**: BH-001

## Context

The UI storyboard specifies a rolling activity log on the host view:
- "ALICE placed 5C"
- "AMERICAN founded with 3 tiles"
- "LUXOR merged into AMERICAN"
- "Trade accepted: BOB gave $500 to CAROL for 2 TOWER"

The backend currently has no event system to support this.

## Requirements

1. Create `GameEvent` dataclass for representing events
2. Add event buffer to `Game` class
3. Emit events for all significant game actions
4. Include recent events in state broadcasts

## Acceptance Criteria

- [ ] `GameEvent` dataclass with timestamp, event_type, player_id, details
- [ ] `Game` class has `_events` list with max 50 recent events
- [ ] Events emitted for: tile placement, chain founding, chain expansion, merger, stock disposition, stock purchase, trade, end turn, game over
- [ ] `get_public_state()` includes `recent_events` field
- [ ] Events are human-readable strings
- [ ] Unit tests for event emission

## Implementation Notes

### GameEvent Dataclass

```python
# backend/game/events.py
from dataclasses import dataclass
from datetime import datetime
from enum import Enum


class EventType(Enum):
    TILE_PLACED = "tile_placed"
    CHAIN_FOUNDED = "chain_founded"
    CHAIN_EXPANDED = "chain_expanded"
    MERGER_STARTED = "merger_started"
    MERGER_COMPLETED = "merger_completed"
    STOCK_DISPOSED = "stock_disposed"
    STOCK_PURCHASED = "stock_purchased"
    TRADE_PROPOSED = "trade_proposed"
    TRADE_ACCEPTED = "trade_accepted"
    TRADE_REJECTED = "trade_rejected"
    TURN_ENDED = "turn_ended"
    GAME_ENDED = "game_ended"


@dataclass
class GameEvent:
    timestamp: datetime
    event_type: EventType
    player_id: str | None
    message: str  # Human-readable description
    details: dict  # Machine-readable data

    def to_dict(self) -> dict:
        return {
            "timestamp": self.timestamp.isoformat(),
            "type": self.event_type.value,
            "player": self.player_id,
            "message": self.message,
            "details": self.details,
        }
```

### Integration with Game Class

```python
# backend/game/game.py
class Game:
    MAX_EVENTS = 50

    def __init__(self):
        # ... existing init ...
        self._events: list[GameEvent] = []

    def _emit_event(self, event_type: EventType, player_id: str | None,
                    message: str, details: dict = None):
        event = GameEvent(
            timestamp=datetime.utcnow(),
            event_type=event_type,
            player_id=player_id,
            message=message,
            details=details or {},
        )
        self._events.append(event)
        if len(self._events) > self.MAX_EVENTS:
            self._events.pop(0)

    def play_tile(self, player_id: str, tile: Tile):
        # ... existing logic ...

        player_name = self._players[player_id].name
        self._emit_event(
            EventType.TILE_PLACED,
            player_id,
            f"{player_name} placed {tile}",
            {"tile": str(tile)}
        )

        # If this founded a chain...
        if result.founded_chain:
            self._emit_event(
                EventType.CHAIN_FOUNDED,
                player_id,
                f"{result.founded_chain} founded with {result.chain_size} tiles",
                {"chain": result.founded_chain, "size": result.chain_size}
            )

    def get_public_state(self) -> dict:
        state = {
            # ... existing fields ...
            "recent_events": [e.to_dict() for e in self._events[-20:]],
        }
        return state
```

### Event Messages

| Event | Message Format |
|-------|---------------|
| Tile placed | "{PLAYER} placed {TILE}" |
| Chain founded | "{CHAIN} founded with {N} tiles" |
| Chain expanded | "{CHAIN} grows to {N} tiles" |
| Merger started | "{CHAIN1} merging into {CHAIN2}" |
| Stock disposed | "{PLAYER} sold {N} {CHAIN}, traded {M}" |
| Stock purchased | "{PLAYER} bought {N} {CHAIN} for ${PRICE}" |
| Trade accepted | "Trade accepted: {PLAYER1} gave {DETAILS} to {PLAYER2}" |
| Game ended | "Game over! {PLAYER} wins with ${AMOUNT}" |

### Files to Create/Modify

1. `backend/game/events.py` - New file with `EventType` and `GameEvent`
2. `backend/game/game.py` - Add event emission throughout
3. `backend/tests/test_events.py` - Unit tests for event emission

## Verification

```bash
cd backend

# Run event tests
pytest tests/test_events.py -v

# Run full test suite
pytest -v

# Manual verification
python -c "
from game.game import Game

game = Game()
game.add_player('p1', 'Alice')
game.add_player('p2', 'Bob')
game.add_player('p3', 'Carol')
game.start_game()

# Simulate some actions...
state = game.get_public_state()
for event in state['recent_events']:
    print(event['message'])
"
```

## Reference

- [Storyboard activity log](../../docs/ui/storyboard.md)
- [Game class](../../backend/game/game.py)
