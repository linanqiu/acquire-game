# BH-008: Full Game Simulation Tests

## Metadata
- **Epic**: Backend Hardening
- **Status**: `complete`
- **Priority**: `high`
- **Effort**: `L` (2-4 hours)
- **Dependencies**: BH-001

## Context

Existing tests focus on individual operations. We need end-to-end tests that play complete games with assertions at each phase to ensure:
- Phase transitions are valid
- State consistency is maintained throughout
- Complex game flows work correctly

## Requirements

1. Create full game simulation tests that play games from start to finish
2. Assert state validity at each phase transition
3. Test mixed human + bot games
4. Test games with multiple mergers
5. Test games that trigger all end-game conditions

## Acceptance Criteria

- [x] At least 5 full game simulation tests (19 tests created)
- [x] Tests verify valid phase transitions (validate_phase_state)
- [x] Tests verify money conservation
- [x] Tests verify stock conservation (validate_stock_conservation)
- [x] Tests cover: normal game end, 41+ tile chain, all safe chains
- [x] Tests with 3, 4, 5, and 6 players (parametrized tests)
- [x] Tests with pure bots
- [x] All tests complete within reasonable time (<1s each)

## Implementation Notes

### Test Structure

```python
# backend/tests/test_full_game_simulation.py
import pytest
from game.game import Game, GamePhase
from game.bot import Bot


class GameStateValidator:
    """Helper to validate game state consistency."""

    @staticmethod
    def validate_money_conservation(game: Game, initial_total: int):
        """Total money in game should equal initial amount."""
        player_money = sum(p.money for p in game._players.values())
        bank_potential = game._calculate_bank_potential()  # Stocks * prices
        # Add merger bonus tracking if needed
        assert player_money <= initial_total, "Money created from nothing"

    @staticmethod
    def validate_stock_conservation(game: Game):
        """Each chain should have exactly 25 stocks total."""
        for chain in ChainName:
            player_stocks = sum(
                p.stocks.get(chain, 0) for p in game._players.values()
            )
            bank_stocks = game._hotel.get_available_stocks(chain)
            assert player_stocks + bank_stocks == 25, f"{chain} stock mismatch"

    @staticmethod
    def validate_phase_transition(from_phase: GamePhase, to_phase: GamePhase):
        """Verify phase transition is valid."""
        valid_transitions = {
            GamePhase.LOBBY: {GamePhase.PLACE_TILE},
            GamePhase.PLACE_TILE: {
                GamePhase.FOUNDING_CHAIN,
                GamePhase.MERGING,
                GamePhase.BUY_STOCKS,
                GamePhase.GAME_OVER,
            },
            GamePhase.FOUNDING_CHAIN: {GamePhase.BUY_STOCKS},
            GamePhase.MERGING: {GamePhase.STOCK_DISPOSITION, GamePhase.BUY_STOCKS},
            GamePhase.STOCK_DISPOSITION: {GamePhase.BUY_STOCKS, GamePhase.STOCK_DISPOSITION},
            GamePhase.BUY_STOCKS: {GamePhase.PLACE_TILE, GamePhase.GAME_OVER},
        }
        assert to_phase in valid_transitions.get(from_phase, set()), \
            f"Invalid transition: {from_phase} -> {to_phase}"


class TestFullGameSimulation:
    """End-to-end game simulation tests."""

    def test_three_player_bot_game_completes(self):
        """Three bot players can complete a full game."""
        game = Game()
        game.add_player("b1", "Bot1", is_bot=True)
        game.add_player("b2", "Bot2", is_bot=True)
        game.add_player("b3", "Bot3", is_bot=True)
        game.start_game()

        bot = Bot("hard")
        turns = 0
        max_turns = 500

        while not game.is_game_over() and turns < max_turns:
            player_id = game.current_player
            prev_phase = game.phase

            action = bot.choose_action(game, player_id)
            game.execute_action(player_id, action)

            # Validate after each action
            GameStateValidator.validate_stock_conservation(game)
            GameStateValidator.validate_phase_transition(prev_phase, game.phase)

            turns += 1

        assert game.is_game_over(), f"Game didn't end in {max_turns} turns"
        assert game.phase == GamePhase.GAME_OVER

    def test_six_player_game_with_mergers(self):
        """Six player game with multiple mergers."""
        game = Game()
        for i in range(6):
            game.add_player(f"p{i}", f"Player{i}", is_bot=True)
        game.start_game()

        bot = Bot("medium")
        merger_count = 0

        while not game.is_game_over():
            player_id = game.current_player
            prev_phase = game.phase

            action = bot.choose_action(game, player_id)
            game.execute_action(player_id, action)

            if prev_phase == GamePhase.PLACE_TILE and game.phase == GamePhase.MERGING:
                merger_count += 1

        # Should have had at least some mergers in a 6-player game
        assert merger_count >= 1, "No mergers occurred in 6-player game"

    def test_game_ends_with_41_tile_chain(self):
        """Game can end via 41+ tile chain."""
        # Setup game to approach 41 tile chain...
        pass

    def test_game_ends_all_safe_chains(self):
        """Game can end when all chains are safe (11+)."""
        pass

    def test_deterministic_replay(self):
        """Same seed produces identical game."""
        seed = 12345

        game1 = Game(seed=seed)
        game1.add_player("p1", "Alice", is_bot=True)
        game1.add_player("p2", "Bob", is_bot=True)
        game1.add_player("p3", "Carol", is_bot=True)
        game1.start_game()

        game2 = Game(seed=seed)
        game2.add_player("p1", "Alice", is_bot=True)
        game2.add_player("p2", "Bob", is_bot=True)
        game2.add_player("p3", "Carol", is_bot=True)
        game2.start_game()

        # Initial hands should match
        for pid in ["p1", "p2", "p3"]:
            assert game1._players[pid].tiles == game2._players[pid].tiles


@pytest.mark.parametrize("num_players", [3, 4, 5, 6])
def test_game_completes_with_n_players(num_players):
    """Games complete successfully with various player counts."""
    game = Game()
    for i in range(num_players):
        game.add_player(f"p{i}", f"Player{i}", is_bot=True)
    game.start_game()

    bot = Bot("hard")
    max_turns = 600

    for _ in range(max_turns):
        if game.is_game_over():
            break
        player_id = game.current_player
        action = bot.choose_action(game, player_id)
        game.execute_action(player_id, action)

    assert game.is_game_over()
```

### Files to Create

1. `backend/tests/test_full_game_simulation.py` - All simulation tests

## Verification

```bash
cd backend

# Run simulation tests
pytest tests/test_full_game_simulation.py -v

# Run with timing to ensure reasonable performance
pytest tests/test_full_game_simulation.py -v --durations=10

# Run full test suite
pytest -v
```

## Reference

- [Existing bot game tests](../../backend/tests/test_bot_games.py)
- [Game class](../../backend/game/game.py)
