# BH-006: Add Tile Playability Details

## Metadata
- **Epic**: Backend Hardening
- **Status**: `not-started`
- **Priority**: `medium`
- **Effort**: `S` (30-60 minutes)
- **Dependencies**: BH-001

## Context

The UI storyboard shows tile playability indicators:
- Playable tiles: normal display
- Temporarily unplayable: "X" overlay (would merge two safe chains)
- Permanently unplayable: "XX" overlay (would create 8th chain)

The backend has `get_unplayable_tiles()` but doesn't distinguish between temporary and permanent unplayability or provide reasons.

## Requirements

1. Add `get_tile_playability(player_id)` method
2. Return playability status and reason for each tile in hand
3. Distinguish temporary vs permanent unplayability
4. Include in player state broadcasts

## Acceptance Criteria

- [ ] `get_tile_playability()` returns dict with each tile's status
- [ ] Status includes: `playable`, `reason` (if not playable), `permanent` flag
- [ ] Reasons: "would_merge_safe_chains", "would_create_eighth_chain", "not_in_hand"
- [ ] Player state includes `tile_playability` field
- [ ] Unit tests for playability detection

## Implementation Notes

### Playability Reasons

| Reason | Description | Permanent? |
|--------|-------------|------------|
| `playable` | Tile can be played | N/A |
| `would_merge_safe_chains` | Would merge 2+ chains with 11+ tiles | Temporary* |
| `would_create_eighth_chain` | Would need to found 8th chain (only 7 exist) | Permanent |

*Temporary because another player might merge one of the safe chains first.

### Implementation

```python
# backend/game/rules.py
from enum import Enum

class UnplayableReason(Enum):
    PLAYABLE = "playable"
    MERGE_SAFE_CHAINS = "would_merge_safe_chains"
    EIGHTH_CHAIN = "would_create_eighth_chain"


def get_tile_playability(board: Board, hotel: Hotel, tile: Tile) -> dict:
    """
    Determine if a tile is playable and why not if it isn't.

    Returns:
        {
            "playable": bool,
            "reason": str | None,
            "permanent": bool | None
        }
    """
    # Check if would merge safe chains
    adjacent_chains = get_adjacent_chains(board, hotel, tile)
    safe_chains = [c for c in adjacent_chains if hotel.get_chain_size(c) >= 11]

    if len(safe_chains) >= 2:
        return {
            "playable": False,
            "reason": UnplayableReason.MERGE_SAFE_CHAINS.value,
            "permanent": False,  # Could become playable if a chain is merged
        }

    # Check if would need to found 8th chain
    if would_need_founding(board, hotel, tile):
        active_chains = hotel.get_active_chains()
        available_chains = hotel.get_available_chains()

        if len(active_chains) == 7 and not available_chains:
            return {
                "playable": False,
                "reason": UnplayableReason.EIGHTH_CHAIN.value,
                "permanent": True,  # Can never be played
            }

    return {
        "playable": True,
        "reason": None,
        "permanent": None,
    }
```

### Integration with Game Class

```python
# backend/game/game.py
class Game:
    def get_player_state(self, player_id: str) -> dict:
        state = self.get_public_state()
        player = self._players[player_id]

        state["your_hand"] = [str(t) for t in player.tiles]

        # Add playability info for each tile
        state["tile_playability"] = {
            str(tile): Rules.get_tile_playability(
                self._board, self._hotel, tile
            )
            for tile in player.tiles
        }

        return state
```

### State Format

```python
{
    "your_hand": ["1A", "3C", "5E", "7G", "9I", "11K"],
    "tile_playability": {
        "1A": {"playable": True, "reason": None, "permanent": None},
        "3C": {"playable": True, "reason": None, "permanent": None},
        "5E": {"playable": False, "reason": "would_merge_safe_chains", "permanent": False},
        "7G": {"playable": False, "reason": "would_create_eighth_chain", "permanent": True},
        "9I": {"playable": True, "reason": None, "permanent": None},
        "11K": {"playable": True, "reason": None, "permanent": None},
    },
    ...
}
```

### Files to Modify

1. `backend/game/rules.py` - Add `get_tile_playability()` function
2. `backend/game/game.py` - Include playability in `get_player_state()`
3. `backend/tests/test_tile_placement.py` - Add playability tests

## Verification

```bash
cd backend

# Run tile placement tests
pytest tests/scenarios/test_tile_placement.py -v

# Run full test suite
pytest -v

# Manual test
python -c "
from game.game import Game
from game.board import Tile

game = Game()
game.add_player('p1', 'Alice')
game.add_player('p2', 'Bob')
game.add_player('p3', 'Carol')
game.start_game()

# Get player state with playability
state = game.get_player_state('p1')
print('Tile playability:')
for tile, info in state['tile_playability'].items():
    status = 'OK' if info['playable'] else f'BLOCKED ({info[\"reason\"]})'
    print(f'  {tile}: {status}')
"
```

## Reference

- [Storyboard - tile indicators](../../docs/ui/storyboard.md)
- [Rules - unplayable tiles](../../backend/game/rules.py)
