# BH-001: Unify State Management

## Metadata
- **Epic**: Backend Hardening
- **Status**: `not-started`
- **Priority**: `critical`
- **Effort**: `L` (2-4 hours)
- **Dependencies**: None

## Context

The backend has dual state management systems:
- `main.py` stores game state as raw dict: `{"board": ..., "hotel": ..., "players": ..., "tile_pool": ..., "phase": ...}`
- `game.py` defines a proper `Game` class with the same structure

This creates maintenance burden, inconsistent behavior, and makes it hard to ensure state validity.

## Requirements

1. Modify `SessionManager` to store `Game` instance instead of dict
2. Update all WebSocket handlers in `main.py` to use `Game` methods
3. Use `Game.get_public_state()` for broadcasting instead of manual dict building
4. Ensure all existing tests pass

## Acceptance Criteria

- [ ] `SessionManager.Room` stores `game: Game` instead of `game: dict`
- [ ] All WebSocket message handlers call `Game` methods (not direct dict manipulation)
- [ ] `broadcast_game_state()` uses `Game.get_public_state()` and `Game.get_player_state()`
- [ ] No raw dict access to game state in `main.py` (except for serialization)
- [ ] All 365 existing tests pass
- [ ] No breaking changes to WebSocket message format (frontend compatibility)

## Implementation Notes

### Step 1: Update SessionManager

```python
# backend/session/manager.py
from game.game import Game

@dataclass
class Room:
    code: str
    host_id: str
    players: dict[str, Player]
    game: Game | None = None  # Changed from dict
    started: bool = False
```

### Step 2: Update Game Start

```python
# main.py - start_game endpoint
async def start_game(room_code: str):
    room = session_manager.get_room(room_code)

    # Create Game instance instead of dict
    game = Game()
    for player_id, player in room.players.items():
        game.add_player(player_id, player.name, is_bot=player.is_bot)
    game.start_game()

    room.game = game
```

### Step 3: Update Message Handlers

Replace patterns like:
```python
# OLD
game = room.game
board = game["board"]
board.place_tile(tile)
game["phase"] = "buy_stocks"
```

With:
```python
# NEW
game = room.game
game.play_tile(tile)  # Game handles phase transitions internally
```

### Step 4: Update Broadcasting

```python
# OLD - Manual dict building
state = {
    "board": board.get_state(),
    "hotel": hotel_state,
    "players": player_states,
    ...
}

# NEW - Use Game methods
public_state = game.get_public_state()
player_state = game.get_player_state(player_id)
```

### Files to Modify

1. `backend/session/manager.py` - Change `game: dict` to `game: Game`
2. `backend/main.py` - All handlers (~20 places)
   - `start_game()`
   - `handle_place_tile()`
   - `handle_found_chain()`
   - `handle_merger_choice()`
   - `handle_merger_disposition()`
   - `handle_buy_stocks()`
   - `handle_end_turn()`
   - `handle_trade_*()` (4 handlers)
   - `broadcast_game_state()`
   - `process_bot_turn()`

## Verification

```bash
cd backend

# Run all existing tests
pytest -v

# Should see: 365 passed

# Check no dict access patterns remain
grep -n 'room.game\["' main.py
# Should return empty

# Run the server and verify WebSocket messages
uvicorn main:app --reload
# Connect with a test client and verify state format unchanged
```

## Reference

- [Game class definition](../../backend/game/game.py)
- [Current main.py handlers](../../backend/main.py)
