# BH-011: WebSocket Reconnection Tests

## Metadata
- **Epic**: Backend Hardening
- **Status**: `complete`
- **Priority**: `medium`
- **Effort**: `M` (1-2 hours)
- **Dependencies**: BH-001

## Context

Players may disconnect and reconnect during a game (phone loses signal, browser refresh, etc.). The backend supports reconnection, but this behavior isn't tested.

## Requirements

1. Add tests for WebSocket disconnection handling
2. Add tests for reconnection and state recovery
3. Test reconnection during various game phases
4. Test multiple reconnections

## Acceptance Criteria

- [x] Tests for graceful disconnect handling (6 tests)
- [x] Tests for reconnection with valid token (3 tests)
- [x] Tests for reconnection with invalid/expired token (1 test)
- [x] Tests for state sync after reconnection (3 async tests)
- [x] Tests for connection state tracking (2 tests)
- [x] Tests for host reconnection (2 tests)
- [x] Tests for multiple disconnects/reconnects (2 tests)
- [x] All tests pass (18 tests)

## Implementation Notes

### Test Structure

```python
# backend/tests/test_websocket_reconnection.py
import pytest
import asyncio
from unittest.mock import AsyncMock, MagicMock, patch
from httpx import AsyncClient
from main import app
from session.manager import session_manager


@pytest.fixture
def mock_websocket():
    """Create mock WebSocket."""
    ws = AsyncMock()
    ws.accept = AsyncMock()
    ws.send_json = AsyncMock()
    ws.receive_json = AsyncMock()
    ws.close = AsyncMock()
    return ws


class TestDisconnectHandling:
    """Tests for handling WebSocket disconnections."""

    @pytest.mark.asyncio
    async def test_disconnect_marks_player_disconnected(self):
        """Disconnect marks player as disconnected but keeps in game."""
        # Setup room with game
        code = session_manager.create_room("host", "Alice")
        session_manager.join_room(code, "p2", "Bob")
        session_manager.join_room(code, "p3", "Carol")

        room = session_manager.get_room(code)
        room.started = True

        # Simulate disconnect
        session_manager.disconnect_player(code, "p2")

        assert room.players["p2"].connected is False
        assert "p2" in room.players  # Still in game

    @pytest.mark.asyncio
    async def test_disconnect_during_turn_pauses_game(self):
        """When current player disconnects, game waits for reconnection."""
        # Setup and start game
        code = session_manager.create_room("host", "Alice")
        session_manager.join_room(code, "p2", "Bob")
        session_manager.join_room(code, "p3", "Carol")

        room = session_manager.get_room(code)
        # ... start game, set current player to p2 ...

        session_manager.disconnect_player(code, "p2")

        # Game should be waiting, not advancing
        assert room.game.current_player == "p2"


class TestReconnection:
    """Tests for player reconnection."""

    @pytest.mark.asyncio
    async def test_reconnect_with_valid_token(self):
        """Player can reconnect with valid token."""
        code = session_manager.create_room("host", "Alice")
        session_manager.join_room(code, "p2", "Bob")

        room = session_manager.get_room(code)
        token = room.players["p2"].token

        # Disconnect
        session_manager.disconnect_player(code, "p2")
        assert room.players["p2"].connected is False

        # Reconnect with same token
        result = session_manager.reconnect_player(code, "p2", token)

        assert result is True
        assert room.players["p2"].connected is True

    @pytest.mark.asyncio
    async def test_reconnect_with_invalid_token_fails(self):
        """Reconnection with invalid token fails."""
        code = session_manager.create_room("host", "Alice")
        session_manager.join_room(code, "p2", "Bob")

        session_manager.disconnect_player(code, "p2")

        result = session_manager.reconnect_player(code, "p2", "invalid_token")

        assert result is False

    @pytest.mark.asyncio
    async def test_reconnect_receives_current_state(self):
        """Reconnected player receives current game state."""
        # This tests the WebSocket endpoint behavior
        pass


class TestReconnectionDuringPhases:
    """Tests for reconnection during specific game phases."""

    @pytest.mark.asyncio
    async def test_reconnect_during_place_tile_phase(self):
        """Player can reconnect and continue during tile placement."""
        pass

    @pytest.mark.asyncio
    async def test_reconnect_during_stock_disposition(self):
        """Player in disposition queue can reconnect and continue."""
        # Setup merger scenario where p2 needs to dispose stock
        # Disconnect p2
        # Reconnect p2
        # Verify p2 can still submit disposition
        pass

    @pytest.mark.asyncio
    async def test_reconnect_during_buy_stocks(self):
        """Player can reconnect during stock buying phase."""
        pass


class TestMultipleReconnections:
    """Tests for multiple disconnect/reconnect cycles."""

    @pytest.mark.asyncio
    async def test_multiple_reconnections_same_player(self):
        """Player can disconnect and reconnect multiple times."""
        code = session_manager.create_room("host", "Alice")
        session_manager.join_room(code, "p2", "Bob")

        room = session_manager.get_room(code)
        token = room.players["p2"].token

        for _ in range(5):
            session_manager.disconnect_player(code, "p2")
            assert room.players["p2"].connected is False

            result = session_manager.reconnect_player(code, "p2", token)
            assert result is True
            assert room.players["p2"].connected is True

    @pytest.mark.asyncio
    async def test_all_players_disconnect_and_reconnect(self):
        """All players can disconnect and reconnect."""
        code = session_manager.create_room("host", "Alice")
        session_manager.join_room(code, "p2", "Bob")
        session_manager.join_room(code, "p3", "Carol")

        room = session_manager.get_room(code)
        tokens = {pid: p.token for pid, p in room.players.items()}

        # Disconnect all
        for pid in room.players:
            session_manager.disconnect_player(code, pid)

        # All disconnected
        assert all(not p.connected for p in room.players.values())

        # Reconnect all
        for pid, token in tokens.items():
            session_manager.reconnect_player(code, pid, token)

        # All reconnected
        assert all(p.connected for p in room.players.values())


class TestReconnectionStateSync:
    """Tests for state synchronization on reconnection."""

    @pytest.mark.asyncio
    async def test_reconnect_syncs_hand(self):
        """Reconnected player receives their current hand."""
        pass

    @pytest.mark.asyncio
    async def test_reconnect_syncs_portfolio(self):
        """Reconnected player receives their stock portfolio."""
        pass

    @pytest.mark.asyncio
    async def test_reconnect_syncs_pending_actions(self):
        """Reconnected player knows what action they need to take."""
        pass
```

### Files to Create

1. `backend/tests/test_websocket_reconnection.py` - All reconnection tests

## Verification

```bash
cd backend

# Run reconnection tests
pytest tests/test_websocket_reconnection.py -v

# Run all WebSocket-related tests
pytest -k "websocket" -v

# Run full test suite
pytest -v
```

## Reference

- [Session manager](../../backend/session/manager.py)
- [WebSocket handlers](../../backend/main.py)
