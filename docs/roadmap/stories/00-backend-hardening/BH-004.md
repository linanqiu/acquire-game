# BH-004: Implement End-Game Declaration

## Metadata
- **Epic**: Backend Hardening
- **Status**: `not-started`
- **Priority**: `high`
- **Effort**: `M` (1-2 hours)
- **Dependencies**: BH-001

## Context

Per the game rules and UI storyboard, when end-game conditions are met (any chain has 41+ tiles OR all active chains are safe), the current player MAY choose to end the game - it's not automatic.

The backend currently auto-triggers game end, which doesn't match the rules.

## Requirements

1. Add `can_declare_end_game()` method to check if declaration is available
2. Add `declare_end_game` WebSocket action
3. Include `end_game_available` flag in player state broadcasts
4. Only end game when player explicitly declares (or chooses to continue)

## Acceptance Criteria

- [ ] `Game.can_declare_end_game()` returns True when conditions met
- [ ] Game does NOT auto-end when conditions met
- [ ] `declare_end_game` WebSocket action triggers game end
- [ ] Player can choose to continue playing (not declare)
- [ ] `end_game_available` flag sent in player state when applicable
- [ ] Unit tests for end-game declaration logic

## Implementation Notes

### End Game Conditions (from rules)

A player MAY declare the game over when:
1. Any single chain has 41 or more tiles, OR
2. All chains on the board are "safe" (11+ tiles each)

### Game Class Updates

```python
# backend/game/game.py
class Game:
    def can_declare_end_game(self) -> bool:
        """Check if current player can declare game over."""
        active_chains = self._hotel.get_active_chains()

        if not active_chains:
            return False

        # Condition 1: Any chain has 41+ tiles
        for chain in active_chains:
            if self._hotel.get_chain_size(chain) >= 41:
                return True

        # Condition 2: All active chains are safe (11+)
        all_safe = all(
            self._hotel.get_chain_size(chain) >= 11
            for chain in active_chains
        )
        return all_safe

    def declare_end_game(self, player_id: str) -> bool:
        """Player declares the game is over."""
        if player_id != self._current_player:
            raise ValueError("Not your turn")

        if not self.can_declare_end_game():
            raise ValueError("End game conditions not met")

        self._finalize_game()
        return True

    def get_player_state(self, player_id: str) -> dict:
        state = self.get_public_state()
        state["your_hand"] = [str(t) for t in self._players[player_id].tiles]

        # Add end game availability for current player
        if player_id == self._current_player:
            state["end_game_available"] = self.can_declare_end_game()

        return state
```

### WebSocket Handler

```python
# backend/main.py
async def handle_declare_end_game(room: Room, player_id: str, data: dict):
    """Handle end game declaration."""
    game = room.game

    if player_id != game.current_player:
        return {"error": "Not your turn"}

    if not game.can_declare_end_game():
        return {"error": "End game conditions not met"}

    game.declare_end_game(player_id)

    await broadcast_game_state(room)
    return {"success": True}
```

### Message Schema

```python
# Incoming message
{
    "type": "declare_end_game"
}

# Player state includes
{
    "end_game_available": true,  # Only when conditions met and it's your turn
    ...
}
```

### Files to Modify

1. `backend/game/game.py` - Add `can_declare_end_game()`, `declare_end_game()`
2. `backend/main.py` - Add WebSocket handler for `declare_end_game`
3. `backend/tests/test_end_game.py` - Add tests for declaration logic

## Verification

```bash
cd backend

# Run end game tests
pytest tests/scenarios/test_end_game.py -v

# Run full test suite
pytest -v

# Manual test
python -c "
from game.game import Game
from game.hotel import ChainName

game = Game()
game.add_player('p1', 'Alice')
game.add_player('p2', 'Bob')
game.add_player('p3', 'Carol')
game.start_game()

# Simulate a chain reaching 41 tiles (for testing)
# ... setup code ...

print('Can declare end game:', game.can_declare_end_game())

if game.can_declare_end_game():
    game.declare_end_game('p1')
    print('Game phase:', game.phase)  # Should be GAME_OVER
"
```

## Reference

- [Game rules - end conditions](../../docs/rules/end-game.md)
- [Storyboard - end game flow](../../docs/ui/storyboard.md)
