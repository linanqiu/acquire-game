# BH-013: Add Typed API Response Classes

## Metadata
- **Epic**: Backend Hardening
- **Status**: `complete`
- **Priority**: `high`
- **Effort**: `M` (1-2 hours)
- **Dependencies**: BH-001

## Context

During BH-001 implementation, a significant maintenance issue was identified: all `Game` class methods return raw dicts without type definitions. For example:

```python
# Current pattern (fragile)
def play_tile(self, player_id: str, tile: Tile) -> dict:
    return {
        "success": True,
        "result": "expand",
        "chain": "Luxor",
        "next_action": "buy_stocks"
    }
```

This creates several problems:
1. **No IDE support** - Can't autocomplete response fields
2. **No validation** - Typos in field names not caught
3. **Documentation drift** - Comments get out of sync with actual fields
4. **Difficult refactoring** - Changing field names is error-prone

## Requirements

1. Create typed dataclasses for all Game method responses
2. Update Game methods to return typed objects
3. Ensure serialization to dict still works for WebSocket handlers
4. Add type hints throughout the interface

## Acceptance Criteria

- [x] `PlayTileResult` dataclass for `play_tile()` response
- [x] `FoundChainResult` dataclass for `found_chain()` response
- [x] `ChooseMergerSurvivorResult` and `StockDispositionResult` dataclasses for merger-related responses
- [x] `BuyStocksResult` dataclass for `buy_stocks()` response
- [x] `EndTurnResult` dataclass for `end_turn()` response
- [x] `EndGameResult` dataclass for `end_game()` response
- [x] All response classes have `to_dict()` method for serialization
- [x] Type hints added to all Game method signatures
- [x] All existing tests pass (dict-like access preserved for backward compatibility)

## Implementation Notes

### Response Classes

```python
# backend/game/responses.py
from dataclasses import dataclass
from typing import Optional, List

@dataclass
class GameResponse:
    """Base class for all game responses."""
    success: bool
    error: Optional[str] = None

    def to_dict(self) -> dict:
        result = {"success": self.success}
        if self.error:
            result["error"] = self.error
        return result


@dataclass
class PlayTileResult(GameResponse):
    """Result of playing a tile."""
    tile: Optional[str] = None
    result_type: Optional[str] = None  # "nothing", "expand", "found", "merge"
    chain: Optional[str] = None  # For expand
    available_chains: Optional[List[str]] = None  # For found
    tied_chains: Optional[List[str]] = None  # For merge tie
    next_action: Optional[str] = None  # "found_chain", "choose_merger_survivor", etc.

    def to_dict(self) -> dict:
        d = super().to_dict()
        if self.tile:
            d["tile"] = self.tile
        if self.result_type:
            d["result"] = self.result_type
        # ... etc
        return d


@dataclass
class FoundChainResult(GameResponse):
    """Result of founding a chain."""
    chain: Optional[str] = None
    founder_stock: bool = False


@dataclass
class EndTurnResult(GameResponse):
    """Result of ending a turn."""
    drew_tile: Optional[str] = None
    replaced_tiles: List[str] = None
    can_end_game: bool = False
    next_player: Optional[str] = None


# ... more response classes
```

### Updated Game Methods

```python
# backend/game/game.py
from .responses import PlayTileResult, FoundChainResult, EndTurnResult

class Game:
    def play_tile(self, player_id: str, tile: Tile) -> PlayTileResult:
        """Play a tile on the board."""
        if self.phase != GamePhase.PLAYING:
            return PlayTileResult(success=False, error="Not in playing phase")

        # ... logic ...

        return PlayTileResult(
            success=True,
            tile=str(tile),
            result_type="expand",
            chain="Luxor",
            next_action="buy_stocks"
        )
```

### Files to Create

1. `backend/game/responses.py` - All response dataclasses (~100 lines)

### Files to Modify

1. `backend/game/game.py` - Update return types and responses (~50 changes)
2. `backend/main.py` - May need `.to_dict()` calls where needed

## Benefits

- **IDE autocomplete** for response fields
- **Type checking** catches typos at development time
- **Self-documenting** - dataclass fields serve as documentation
- **Easier refactoring** - change in one place propagates everywhere
- **Better testing** - can assert on typed objects

## Verification

```bash
cd backend

# Type checking (if using mypy)
mypy game/responses.py game/game.py

# Run all tests
pytest -v

# Verify WebSocket still works
# Start server and connect with test client
```

## Reference

- [Python dataclasses](https://docs.python.org/3/library/dataclasses.html)
- [Game class methods](../../backend/game/game.py)
