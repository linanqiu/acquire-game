# SH-003: Configure CORS

## Metadata
- **Epic**: Security Hardening
- **Status**: `not-started`
- **Priority**: `medium`
- **Effort**: `XS` (<30m)
- **Dependencies**: None

## Context

The backend currently has no CORS configuration, which means:
1. Any origin can make requests to the API
2. Credentials (cookies, auth headers) may be exposed
3. No protection against cross-site request forgery

## Requirements

1. Configure CORS with explicit allowed origins
2. Support different origins for development vs production
3. Allow credentials for authenticated requests
4. Restrict allowed methods and headers

## Acceptance Criteria

- [ ] CORS middleware configured in FastAPI app
- [ ] Development allows localhost origins (localhost:5173, localhost:3000)
- [ ] Production restricts to actual domain(s)
- [ ] Credentials allowed for session token auth
- [ ] Preflight requests handled correctly
- [ ] Tests verify CORS headers in responses

## Implementation Notes

### FastAPI CORS Configuration

```python
from fastapi.middleware.cors import CORSMiddleware
import os

# Determine environment
ENVIRONMENT = os.getenv("ENVIRONMENT", "development")

# Define allowed origins
ALLOWED_ORIGINS = {
    "development": [
        "http://localhost:5173",  # Vite dev server
        "http://localhost:3000",  # Alternative dev port
        "http://127.0.0.1:5173",
        "http://127.0.0.1:3000",
    ],
    "production": [
        "https://acquire.example.com",  # Replace with actual domain
        # Add additional production origins as needed
    ]
}

origins = ALLOWED_ORIGINS.get(ENVIRONMENT, ALLOWED_ORIGINS["development"])

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["GET", "POST", "OPTIONS"],
    allow_headers=["Authorization", "Content-Type"],
    expose_headers=["X-Request-ID"],  # If using request tracing
)
```

### Environment Variable

Add to deployment configuration:
```bash
ENVIRONMENT=production
ALLOWED_ORIGINS=https://acquire.example.com,https://www.acquire.example.com
```

### WebSocket CORS

Note: WebSocket connections don't use CORS (they use Origin header checking). Consider adding origin validation in WebSocket handlers:

```python
@app.websocket("/ws/player/{room_code}/{player_id}")
async def player_websocket(websocket: WebSocket, ...):
    origin = websocket.headers.get("origin", "")
    if ENVIRONMENT == "production" and origin not in origins:
        await websocket.close(code=4003, reason="Origin not allowed")
        return
    # ... rest of handler
```

## Verification

```bash
# Test CORS headers present
curl -i -X OPTIONS http://localhost:8000/create \
  -H "Origin: http://localhost:5173" \
  -H "Access-Control-Request-Method: POST"

# Should see:
# Access-Control-Allow-Origin: http://localhost:5173
# Access-Control-Allow-Credentials: true
# Access-Control-Allow-Methods: GET, POST, OPTIONS

# Test blocked origin (production)
ENVIRONMENT=production python -m uvicorn main:app &
curl -i -X OPTIONS http://localhost:8000/create \
  -H "Origin: http://evil.com" \
  -H "Access-Control-Request-Method: POST"
# Should NOT have Access-Control-Allow-Origin header
```

## Notes

- CORS is browser-enforced; API clients (curl, Postman) bypass it
- WebSocket needs separate origin checking
- Consider using `allow_origin_regex` for subdomain support
