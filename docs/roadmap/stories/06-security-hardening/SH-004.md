# SH-004: Sanitize Player Name Input

## Metadata
- **Epic**: Security Hardening
- **Status**: `not-started`
- **Priority**: `medium`
- **Effort**: `XS` (<30m)
- **Dependencies**: None

## Context

Player names are accepted from user input and broadcast to all clients. Currently there's no sanitization, which could lead to:
1. XSS if names are rendered as HTML in frontend
2. Display issues with special characters
3. Impersonation with invisible/confusing Unicode

## Requirements

1. Sanitize player names on input (backend)
2. Enforce reasonable length limits
3. Strip or reject dangerous characters
4. Normalize Unicode to prevent homograph attacks

## Acceptance Criteria

- [ ] Player names limited to 2-20 characters
- [ ] HTML special characters escaped or stripped
- [ ] Only alphanumeric, spaces, and basic punctuation allowed
- [ ] Leading/trailing whitespace trimmed
- [ ] Empty or whitespace-only names rejected
- [ ] Tests verify sanitization rules

## Implementation Notes

### Pydantic Validator Approach

```python
from pydantic import BaseModel, field_validator
import re
import html

class PlayerNameInput(BaseModel):
    player_name: str

    @field_validator('player_name')
    @classmethod
    def sanitize_name(cls, v: str) -> str:
        # Trim whitespace
        v = v.strip()

        # Check length
        if len(v) < 2:
            raise ValueError("Name must be at least 2 characters")
        if len(v) > 20:
            raise ValueError("Name must be at most 20 characters")

        # Allow only safe characters: alphanumeric, space, basic punctuation
        if not re.match(r'^[\w\s\-_.]+$', v, re.UNICODE):
            raise ValueError("Name contains invalid characters")

        # Escape HTML entities as extra safety
        v = html.escape(v)

        # Collapse multiple spaces
        v = re.sub(r'\s+', ' ', v)

        return v
```

### Apply to Endpoints

```python
@app.post("/create")
async def create_room(player_name: str = Form(...)):
    # Validate using the model
    validated = PlayerNameInput(player_name=player_name)
    clean_name = validated.player_name
    # ... rest of handler
```

### Alternative: Utility Function

```python
def sanitize_player_name(name: str) -> str:
    """Sanitize player name input."""
    name = name.strip()

    if not name:
        raise ValueError("Name cannot be empty")
    if len(name) < 2:
        raise ValueError("Name must be at least 2 characters")
    if len(name) > 20:
        raise ValueError("Name must be at most 20 characters")

    # Whitelist approach: only allow safe characters
    allowed = set('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 -_.')
    if not all(c in allowed for c in name):
        raise ValueError("Name contains invalid characters. Use letters, numbers, spaces, hyphens, underscores, or periods.")

    # Collapse multiple spaces
    name = ' '.join(name.split())

    return name
```

### Frontend Validation (Defense in Depth)

Also add client-side validation in the join form:
```typescript
const NAME_PATTERN = /^[\w\s\-_.]{2,20}$/;

function validatePlayerName(name: string): string | null {
  const trimmed = name.trim();
  if (trimmed.length < 2) return "Name must be at least 2 characters";
  if (trimmed.length > 20) return "Name must be at most 20 characters";
  if (!NAME_PATTERN.test(trimmed)) return "Name contains invalid characters";
  return null; // Valid
}
```

## Verification

```bash
# Run sanitization tests
cd backend && pytest tests/test_input_validation.py -v

# Test various inputs
curl -X POST -d "player_name=<script>alert(1)</script>" http://localhost:8000/create
# Should reject or escape

curl -X POST -d "player_name=   " http://localhost:8000/create
# Should reject (empty after trim)

curl -X POST -d "player_name=ValidName123" http://localhost:8000/create
# Should succeed
```

## Notes

- Frontend should also validate but never trust client validation alone
- Consider logging rejected names for abuse monitoring
- May want to add profanity filter in future (not in scope here)
