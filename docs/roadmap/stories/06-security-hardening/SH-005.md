# SH-005: Room Cleanup and Memory Management

## Metadata
- **Epic**: Security Hardening
- **Status**: `not-started`
- **Priority**: `medium`
- **Effort**: `M` (1-2h)
- **Dependencies**: None

## Context

Rooms are created but only deleted when explicitly empty. If players disconnect without proper cleanup (browser crash, network loss), rooms persist indefinitely in memory. This causes:
1. Memory leaks over time
2. Room code collisions more likely
3. Stale game state consuming resources

## Requirements

1. Automatically clean up stale rooms
2. Track last activity time per room
3. Configurable inactivity timeout
4. Graceful handling of reconnection window
5. Log cleanup events for monitoring

## Acceptance Criteria

- [ ] Rooms track last activity timestamp
- [ ] Background task checks for stale rooms periodically
- [ ] Rooms deleted after 30 minutes of inactivity (configurable)
- [ ] Active WebSocket connections reset the timer
- [ ] Game actions reset the timer
- [ ] Cleanup logged for debugging
- [ ] Tests verify cleanup behavior

## Implementation Notes

### Add Activity Tracking to Room

```python
# session/manager.py
from datetime import datetime, timedelta

class Room:
    def __init__(self, code: str, host_name: str):
        self.code = code
        self.host_name = host_name
        self.players: dict[str, PlayerConnection] = {}
        self.game: Optional[Game] = None
        self.created_at: datetime = datetime.utcnow()
        self.last_activity: datetime = datetime.utcnow()

    def touch(self):
        """Update last activity timestamp."""
        self.last_activity = datetime.utcnow()

    def is_stale(self, timeout_minutes: int = 30) -> bool:
        """Check if room has been inactive too long."""
        return datetime.utcnow() - self.last_activity > timedelta(minutes=timeout_minutes)
```

### Background Cleanup Task

```python
# main.py
import asyncio
from contextlib import asynccontextmanager

ROOM_TIMEOUT_MINUTES = int(os.getenv("ROOM_TIMEOUT_MINUTES", "30"))
CLEANUP_INTERVAL_SECONDS = 60  # Check every minute

async def cleanup_stale_rooms():
    """Background task to remove inactive rooms."""
    while True:
        await asyncio.sleep(CLEANUP_INTERVAL_SECONDS)

        stale_rooms = []
        for code, room in list(session_manager.rooms.items()):
            if room.is_stale(ROOM_TIMEOUT_MINUTES):
                stale_rooms.append(code)

        for code in stale_rooms:
            room = session_manager.rooms.get(code)
            if room:
                # Close any remaining connections
                for player_conn in room.players.values():
                    for ws in player_conn.websockets:
                        try:
                            await ws.close(code=4002, reason="Room expired due to inactivity")
                        except Exception:
                            pass

                # Remove room
                del session_manager.rooms[code]
                logger.info(f"Cleaned up stale room {code} (inactive for {ROOM_TIMEOUT_MINUTES}+ minutes)")

@asynccontextmanager
async def lifespan(app: FastAPI):
    # Start background task
    cleanup_task = asyncio.create_task(cleanup_stale_rooms())
    yield
    # Cancel on shutdown
    cleanup_task.cancel()
    try:
        await cleanup_task
    except asyncio.CancelledError:
        pass

app = FastAPI(lifespan=lifespan)
```

### Touch on Activity

Update activity timestamp in key handlers:

```python
# In player_websocket handler
async def player_websocket(...):
    room.touch()  # Connection established

    async for message in websocket.iter_json():
        room.touch()  # Activity on message
        # ... handle message

# In REST endpoints
@app.post("/room/{room_code}/start")
async def start_game(room_code: str, ...):
    room = session_manager.get_room(room_code)
    if room:
        room.touch()
    # ...
```

### Reconnection Grace Period

Consider allowing recently-disconnected players to reconnect:

```python
class PlayerConnection:
    def __init__(self, ...):
        self.disconnected_at: Optional[datetime] = None

    def can_reconnect(self, grace_minutes: int = 5) -> bool:
        if self.disconnected_at is None:
            return True
        return datetime.utcnow() - self.disconnected_at < timedelta(minutes=grace_minutes)
```

## Verification

```bash
# Run cleanup tests
cd backend && pytest tests/test_room_cleanup.py -v

# Manual test with short timeout
ROOM_TIMEOUT_MINUTES=1 python -m uvicorn main:app --reload &

# Create room
curl -X POST -d "player_name=test" http://localhost:8000/create
# Note room code

# Wait 2 minutes, check if room still exists
sleep 120
curl http://localhost:8000/room/XXXX/state
# Should return 404 (room cleaned up)
```

## Monitoring

Add metrics for:
- Rooms cleaned up per hour
- Average room lifetime
- Rooms currently active
- Peak concurrent rooms

## Notes

- Consider Redis for room state if scaling horizontally
- May want to persist game state before cleanup for crash recovery
- WebSocket ping/pong can detect dead connections faster
