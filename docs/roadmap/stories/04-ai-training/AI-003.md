# AI-003: State Encoder Implementation

## Metadata
- **Epic**: AI Training
- **Status**: `not-started`
- **Priority**: `high`
- **Effort**: `M` (1-2 hours)
- **Dependencies**: None (spec exists in docs/ai/state_encoding.md)

## Context

Implement the state encoder that converts game state to a fixed-size tensor for neural network input. This is the foundation for all neural bot training.

## Requirements

1. Encode board state (108 tiles)
2. Encode chain information (7 chains × features)
3. Encode player information (6 players × features)
4. Encode hand tiles (6 tiles)
5. Encode game phase and meta info
6. Produce ~750 dimensional vector

## Acceptance Criteria

- [ ] Encode board as 108-dim vector
- [ ] Encode chains as 35-dim (7 × 5 features)
- [ ] Encode players as 54-dim (6 × 9 features)
- [ ] Encode hand as 6-dim
- [ ] Encode phase as 7-dim one-hot
- [ ] Encode meta info as 10-dim
- [ ] Total ~750 dimensions
- [ ] Roundtrip test: encode/decode matches
- [ ] Normalized values (0-1 range)
- [ ] Unit tests for each component

## Implementation Notes

### File to Create

**backend/training/state_encoder.py**:
```python
import numpy as np
from typing import List, Optional
from game.game import Game
from game.hotel import CHAINS


class StateEncoder:
    """Encode Acquire game state as fixed-size tensor."""

    # Dimensions
    BOARD_DIM = 108  # 12 × 9 grid flattened
    CHAIN_DIM = 35   # 7 chains × 5 features
    PLAYER_DIM = 54  # 6 players × 9 features (active, cash, 7 stocks)
    HAND_DIM = 6     # 6 tile indices
    PHASE_DIM = 7    # One-hot encoded phase
    META_DIM = 10    # Current player (6), can_end (1), pending_action (5)

    TOTAL_DIM = BOARD_DIM + CHAIN_DIM + PLAYER_DIM + HAND_DIM + PHASE_DIM + META_DIM

    PHASES = ['lobby', 'tile_played', 'founding', 'merging', 'buying', 'game_over', 'other']
    CHAIN_NAMES = list(CHAINS.keys())

    def __init__(self, max_players: int = 6):
        self.max_players = max_players

    def encode(self, game: Game, player_id: str) -> np.ndarray:
        """Encode full game state from player's perspective."""
        state = np.zeros(self.TOTAL_DIM, dtype=np.float32)
        idx = 0

        # Board (108)
        board_encoding = self._encode_board(game)
        state[idx:idx + self.BOARD_DIM] = board_encoding
        idx += self.BOARD_DIM

        # Chains (35)
        chain_encoding = self._encode_chains(game)
        state[idx:idx + self.CHAIN_DIM] = chain_encoding
        idx += self.CHAIN_DIM

        # Players (54)
        player_encoding = self._encode_players(game, player_id)
        state[idx:idx + self.PLAYER_DIM] = player_encoding
        idx += self.PLAYER_DIM

        # Hand (6)
        hand_encoding = self._encode_hand(game, player_id)
        state[idx:idx + self.HAND_DIM] = hand_encoding
        idx += self.HAND_DIM

        # Phase (7)
        phase_encoding = self._encode_phase(game)
        state[idx:idx + self.PHASE_DIM] = phase_encoding
        idx += self.PHASE_DIM

        # Meta (10)
        meta_encoding = self._encode_meta(game, player_id)
        state[idx:idx + self.META_DIM] = meta_encoding

        return state

    def _encode_board(self, game: Game) -> np.ndarray:
        """Encode 12×9 board as 108-dim vector."""
        encoding = np.zeros(108, dtype=np.float32)

        for row_idx, row in enumerate(game.board.grid):
            for col_idx, tile in enumerate(row):
                flat_idx = row_idx * 12 + col_idx

                if tile.state == 'empty':
                    encoding[flat_idx] = 0.0
                elif tile.state == 'orphan':
                    encoding[flat_idx] = 0.1
                elif tile.chain:
                    chain_idx = self.CHAIN_NAMES.index(tile.chain)
                    encoding[flat_idx] = 0.2 + (chain_idx * 0.1)

        return encoding

    def _encode_chains(self, game: Game) -> np.ndarray:
        """Encode 7 chains × 5 features = 35 dims."""
        encoding = np.zeros(35, dtype=np.float32)

        for i, chain_name in enumerate(self.CHAIN_NAMES):
            chain = game.chains.get(chain_name)
            base_idx = i * 5

            if chain and chain.active:
                encoding[base_idx] = chain.size / 41.0  # Normalized size
                encoding[base_idx + 1] = chain.price / 1200.0  # Normalized price
                encoding[base_idx + 2] = chain.stock_available / 25.0  # Normalized stock
                encoding[base_idx + 3] = 1.0  # Active flag
                encoding[base_idx + 4] = 1.0 if chain.size >= 11 else 0.0  # Safe flag

        return encoding

    def _encode_players(self, game: Game, my_player_id: str) -> np.ndarray:
        """Encode 6 players × 9 features = 54 dims.

        Rotate so current player is always first.
        """
        encoding = np.zeros(54, dtype=np.float32)
        players = game.get_players_from(my_player_id)  # Rotated list

        for i, player in enumerate(players[:self.max_players]):
            base_idx = i * 9

            encoding[base_idx] = 1.0  # Active flag
            encoding[base_idx + 1] = player.cash / 50000.0  # Normalized cash

            # Stock holdings (7 chains)
            for j, chain_name in enumerate(self.CHAIN_NAMES):
                encoding[base_idx + 2 + j] = player.stocks.get(chain_name, 0) / 25.0

        return encoding

    def _encode_hand(self, game: Game, player_id: str) -> np.ndarray:
        """Encode player's 6 tiles as indices."""
        encoding = np.zeros(6, dtype=np.float32)
        player = game.get_player(player_id)

        if player:
            for i, tile in enumerate(player.tiles[:6]):
                # Convert coordinate to index (0-107)
                col = int(tile[:-1]) - 1
                row = ord(tile[-1]) - ord('A')
                flat_idx = row * 12 + col
                encoding[i] = flat_idx / 107.0

        return encoding

    def _encode_phase(self, game: Game) -> np.ndarray:
        """Encode game phase as one-hot."""
        encoding = np.zeros(7, dtype=np.float32)
        phase_idx = self.PHASES.index(game.phase) if game.phase in self.PHASES else 6
        encoding[phase_idx] = 1.0
        return encoding

    def _encode_meta(self, game: Game, player_id: str) -> np.ndarray:
        """Encode meta information."""
        encoding = np.zeros(10, dtype=np.float32)

        # Current player one-hot (6)
        players = game.get_player_ids()
        current_idx = players.index(game.current_player_id) if game.current_player_id in players else 0
        encoding[current_idx] = 1.0

        # Can end game flag (1)
        encoding[6] = 1.0 if game.can_end_game() else 0.0

        # Pending action type (3) - simplified
        # Could expand based on specific pending actions

        return encoding
```

## Verification

```bash
cd backend
python -m pytest tests/test_state_encoder.py -v

# Verify dimensions
python -c "
from training.state_encoder import StateEncoder
print(f'Total dimensions: {StateEncoder.TOTAL_DIM}')
"
```

## Reference

- [State Encoding Spec](../../../ai/state_encoding.md)
