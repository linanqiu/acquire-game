# AI-007: Neural Bot Integration

## Metadata
- **Epic**: AI Training
- **Status**: `not-started`
- **Priority**: `high`
- **Effort**: `M` (1-2 hours)
- **Dependencies**: AI-006

## Context

Create a NeuralBot class that uses the trained policy network to play Acquire. Must integrate with the existing bot interface.

## Requirements

1. Load trained model
2. Implement choose_action() interface
3. Handle action encoding/decoding
4. Match existing Bot API

## Acceptance Criteria

- [ ] NeuralBot class with same API as Bot
- [ ] Loads model from checkpoint
- [ ] Encodes state using StateEncoder
- [ ] Decodes action from network output
- [ ] Handles action masking for legal moves
- [ ] Inference <10ms per move
- [ ] Win rate within 5% of hard bot
- [ ] Playable via WebSocket UI
- [ ] Unit tests for integration

## Implementation Notes

### File to Create

**backend/game/neural_bot.py**:
```python
import numpy as np
from typing import Optional
from pathlib import Path

from .action import Action
from .rules import Rules
from training.state_encoder import StateEncoder
from training.policy_network import PolicyNetwork, ActionEncoder


class NeuralBot:
    """Bot using trained neural network policy."""

    def __init__(
        self,
        model_path: str = 'checkpoints/best_model.pt',
        deterministic: bool = False,
    ):
        self.model = PolicyNetwork.load(model_path)
        self.model.eval()

        self.encoder = StateEncoder()
        self.action_encoder = ActionEncoder()
        self.deterministic = deterministic

    def choose_action(self, game, player_id: str) -> Action:
        """Choose action using neural network policy."""
        # Get legal actions
        legal_actions = Rules.get_all_legal_actions(game, player_id)

        if not legal_actions:
            raise ValueError("No legal actions available")

        if len(legal_actions) == 1:
            return legal_actions[0]

        # Encode state
        state = self.encoder.encode(game, player_id)

        # Create action mask
        mask = self.action_encoder.get_mask(legal_actions)

        # Get action index from network
        action_idx = self.model.get_action(
            state, mask, deterministic=self.deterministic
        )

        # Decode to action
        # Map network output back to legal action
        legal_indices = [self.action_encoder.encode(a) for a in legal_actions]

        if action_idx in legal_indices:
            return legal_actions[legal_indices.index(action_idx)]

        # Fallback: return action with highest probability among legal
        return self._select_best_legal(state, legal_actions)

    def _select_best_legal(self, state: np.ndarray, legal_actions: list) -> Action:
        """Select best legal action when network output is invalid."""
        import torch

        with torch.no_grad():
            state_t = torch.FloatTensor(state).unsqueeze(0)
            logits = self.model.policy_head(self.model.backbone(state_t))
            probs = logits.softmax(dim=-1).squeeze(0).numpy()

        best_prob = -1
        best_action = legal_actions[0]

        for action in legal_actions:
            idx = self.action_encoder.encode(action)
            if idx < len(probs) and probs[idx] > best_prob:
                best_prob = probs[idx]
                best_action = action

        return best_action


class NeuralBotFactory:
    """Factory for creating neural bots with different models."""

    _cache = {}

    @classmethod
    def create(
        cls,
        model_name: str = 'default',
        deterministic: bool = False,
    ) -> NeuralBot:
        """Create or get cached neural bot."""
        cache_key = (model_name, deterministic)

        if cache_key not in cls._cache:
            model_path = cls._get_model_path(model_name)
            cls._cache[cache_key] = NeuralBot(model_path, deterministic)

        return cls._cache[cache_key]

    @classmethod
    def _get_model_path(cls, model_name: str) -> str:
        """Get model path from name."""
        paths = {
            'default': 'checkpoints/best_model.pt',
            'v1': 'checkpoints/v1_model.pt',
            'v2': 'checkpoints/v2_model.pt',
        }
        return paths.get(model_name, model_name)
```

### Update main.py to support neural bots

**backend/main.py** (add to bot creation):
```python
from game.neural_bot import NeuralBotFactory

def create_bot(bot_type: str):
    if bot_type == 'neural':
        return NeuralBotFactory.create()
    elif bot_type in ['easy', 'medium', 'hard']:
        return Bot(bot_type)
    else:
        raise ValueError(f"Unknown bot type: {bot_type}")
```

## Verification

```bash
cd backend
python -m pytest tests/test_neural_bot.py -v

# Play test game
python -c "
from game.game import Game
from game.neural_bot import NeuralBot
from game.bot import Bot

game = Game()
game.add_player('neural', 'NeuralBot')
game.add_player('hard1', 'HardBot1')
game.add_player('hard2', 'HardBot2')
game.start_game()

neural = NeuralBot()
hard = Bot('hard')

while not game.is_game_over():
    player = game.get_current_player_id()
    if player == 'neural':
        action = neural.choose_action(game, player)
    else:
        action = hard.choose_action(game, player)
    game.apply_action(action)

print('Final rankings:', game.get_final_rankings())
"
```

## Reference

- [AI Roadmap - Neural Bot](../../../ai/ROADMAP.md#phase-2-neural-bot-learning-based)
