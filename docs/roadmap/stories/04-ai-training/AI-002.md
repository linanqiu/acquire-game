# AI-002: MCTS Enhanced

## Metadata
- **Epic**: AI Training
- **Status**: `not-started`
- **Priority**: `medium`
- **Effort**: `M` (1-2 hours)
- **Dependencies**: AI-001

## Context

Enhance MCTS with UCB1 selection, progressive widening, and heuristic rollouts. These improvements increase playing strength significantly.

## Requirements

1. UCB1 action selection (exploration/exploitation balance)
2. Tree structure with node expansion
3. Heuristic rollouts using easy bot
4. Transposition table for caching

## Acceptance Criteria

- [ ] UCB1 selection implemented
- [ ] Tree maintains visit counts
- [ ] Heuristic rollouts use easy bot
- [ ] Transposition table caches positions
- [ ] >10% improvement vs basic MCTS
- [ ] Beats hard bot >60% of games
- [ ] Unit tests for tree operations

## Implementation Notes

### Update File

**backend/game/mcts_bot.py** (enhanced version):
```python
import math
from collections import defaultdict
from typing import Dict, List, Optional, Tuple
from .game import Game
from .action import Action
from .rules import Rules
from .bot import Bot


class EnhancedMCTSBot:
    """MCTS with UCB1 selection and heuristic rollouts."""

    def __init__(
        self,
        simulations: int = 1000,
        exploration: float = 1.41,
        use_heuristic_rollout: bool = True,
        seed: Optional[int] = None,
    ):
        self.simulations = simulations
        self.exploration = exploration
        self.use_heuristic = use_heuristic_rollout
        self.rollout_bot = Bot("easy") if use_heuristic_rollout else None

        # Tree statistics
        self.visits: Dict[str, int] = defaultdict(int)
        self.wins: Dict[str, float] = defaultdict(float)

    def choose_action(self, game: Game, player_id: str) -> Action:
        """Choose best action using enhanced MCTS."""
        root_state = self._state_key(game)
        legal_actions = Rules.get_all_legal_actions(game, player_id)

        if len(legal_actions) <= 1:
            return legal_actions[0] if legal_actions else None

        # Run simulations
        for _ in range(self.simulations):
            self._simulate(game.clone(), player_id, root_state)

        # Select best action by visit count
        best_action = None
        best_visits = -1

        for action in legal_actions:
            key = f"{root_state}:{action}"
            if self.visits[key] > best_visits:
                best_visits = self.visits[key]
                best_action = action

        return best_action

    def _simulate(self, game: Game, player_id: str, state_key: str) -> float:
        """Run one MCTS simulation with UCB1 selection."""
        path = []  # (state_key, action) pairs

        # Selection phase: traverse tree using UCB1
        while not game.is_game_over():
            current_player = game.get_current_player_id()
            actions = Rules.get_all_legal_actions(game, current_player)

            if not actions:
                break

            current_state = self._state_key(game)

            # Check if node is fully expanded
            unexpanded = [a for a in actions if self.visits[f"{current_state}:{a}"] == 0]

            if unexpanded:
                # Expansion: try an unexpanded action
                action = unexpanded[0]
            else:
                # Selection: use UCB1
                action = self._ucb1_select(current_state, actions)

            path.append((current_state, action))
            game.apply_action(action)

            # If we expanded, do rollout from here
            if unexpanded:
                break

        # Rollout phase
        result = self._rollout(game, player_id)

        # Backpropagation
        for state, action in path:
            key = f"{state}:{action}"
            self.visits[key] += 1
            self.wins[key] += result

        return result

    def _ucb1_select(self, state: str, actions: List[Action]) -> Action:
        """Select action using UCB1 formula."""
        total_visits = sum(self.visits[f"{state}:{a}"] for a in actions)

        best_ucb = -float('inf')
        best_action = actions[0]

        for action in actions:
            key = f"{state}:{action}"
            n = self.visits[key]

            if n == 0:
                return action  # Always try unvisited

            exploitation = self.wins[key] / n
            exploration = self.exploration * math.sqrt(math.log(total_visits) / n)
            ucb = exploitation + exploration

            if ucb > best_ucb:
                best_ucb = ucb
                best_action = action

        return best_action

    def _rollout(self, game: Game, player_id: str) -> float:
        """Complete game using rollout policy."""
        while not game.is_game_over():
            current_player = game.get_current_player_id()
            actions = Rules.get_all_legal_actions(game, current_player)

            if not actions:
                break

            if self.use_heuristic and self.rollout_bot:
                # Use easy bot for smarter rollout
                action = self.rollout_bot.choose_action(game, current_player)
            else:
                # Random rollout
                action = actions[0]  # Or random.choice(actions)

            game.apply_action(action)

        return self._evaluate(game, player_id)

    def _evaluate(self, game: Game, player_id: str) -> float:
        """Evaluate final game state for player."""
        rankings = game.get_final_rankings()
        my_rank = next(
            (i for i, r in enumerate(rankings) if r['player_id'] == player_id),
            len(rankings)
        )

        # Graduated rewards
        if my_rank == 0:
            return 1.0
        elif my_rank == 1:
            return 0.4
        elif my_rank == 2:
            return 0.1
        return 0.0

    def _state_key(self, game: Game) -> str:
        """Create hashable state key for transposition table."""
        # Simple hash based on game phase and turn
        return f"{game.phase}:{game.turn_number}"
```

## Verification

```bash
cd backend
python -m pytest tests/test_mcts_bot.py -v

# Benchmark enhanced vs basic
python -c "
# Run comparison games
"
```

## Reference

- [AI Roadmap - Enhanced MCTS](../../../ai/ROADMAP.md#12-enhanced-mcts)
