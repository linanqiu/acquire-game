# FF-011: E2E Testing Infrastructure

## Metadata
- **Epic**: Frontend Foundation
- **Status**: `not-started`
- **Priority**: `high`
- **Effort**: `M` (1-2 hours)
- **Dependencies**: FF-001

## Context

FF-001 established the basic testing foundation, but real E2E testing requires additional infrastructure to test realistic scenarios including:
- Frontend + backend integration
- Bot player behavior
- WebSocket message flows
- Deterministic game scenarios

This story creates the infrastructure needed for meaningful E2E tests that verify the full stack works together.

## Requirements

1. Configure Playwright to start both frontend and backend servers
2. Align frontend TypeScript types with backend API schemas
3. Create E2E test helpers for common operations (room creation, bot games, waiting for turns)
4. Add integration test utilities for WebSocket testing without browser
5. Support deterministic game seeding for reproducible tests

## Acceptance Criteria

- [ ] `npm run e2e` starts both frontend (5173) and backend (8000) automatically
- [ ] E2E tests can create rooms, add bots, and play through game scenarios
- [ ] Frontend types match backend WebSocket message schemas
- [ ] Helper utilities exist for: `createRoom`, `joinRoom`, `addBot`, `startGame`, `waitForPhase`, `playTile`
- [ ] At least one E2E test plays a complete game with human + bot players
- [ ] Tests are deterministic (same seed = same game outcome)

## Implementation Notes

### 1. Update Playwright Config for Multi-Server

**playwright.config.ts**:
```typescript
import { defineConfig, devices } from '@playwright/test'

export default defineConfig({
  testDir: './tests/e2e',
  fullyParallel: true,
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  workers: process.env.CI ? 1 : undefined,
  reporter: 'html',
  use: {
    baseURL: 'http://localhost:5173',
    trace: 'on-first-retry',
  },
  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
    },
  ],
  webServer: [
    {
      command: 'cd ../backend && python -m uvicorn main:app --port 8000',
      url: 'http://localhost:8000/docs',
      reuseExistingServer: !process.env.CI,
      timeout: 30000,
    },
    {
      command: 'npm run dev',
      url: 'http://localhost:5173',
      reuseExistingServer: !process.env.CI,
    },
  ],
})
```

### 2. Align Types with Backend

**src/types/api.ts** - Types matching backend Pydantic models:
```typescript
// Chain names as used by backend (title case)
export type ChainName =
  | 'Luxor' | 'Tower' | 'American' | 'Festival'
  | 'Worldwide' | 'Continental' | 'Imperial'

// WebSocket message types from backend
export interface GameStateMessage {
  type: 'game_state'
  board: Record<string, string | null>
  hotel: {
    chains: Array<{
      name: ChainName
      size: number
      price: number
      stocks_available: number
    }>
    available_stocks: Record<ChainName, number>
    active_chains: ChainName[]
  }
  turn_order: string[]
  current_player: string
  phase: 'waiting' | 'playing' | 'game_over'
  players: Record<string, {
    name: string
    money: number
    stocks: Record<ChainName, number>
    hand_size: number
  }>
  tiles_remaining: number
  your_hand?: string[]  // Only sent to the owning player
}

export interface LobbyUpdateMessage {
  type: 'lobby_update'
  players: Array<{ player_id: string; name: string; is_bot: boolean }>
  can_start: boolean
}

export interface ChooseChainMessage {
  type: 'choose_chain'
  available_chains: ChainName[]
}

export interface StockDispositionMessage {
  type: 'stock_disposition_required'
  defunct_chain: ChainName
  surviving_chain: ChainName
  stock_count: number
  available_to_trade: number
}

export interface ErrorMessage {
  type: 'error'
  message: string
}

export interface GameOverMessage {
  type: 'game_over'
  scores: Record<string, { name: string; money: number }>
  winner: string
}

export type WebSocketMessage =
  | GameStateMessage
  | LobbyUpdateMessage
  | ChooseChainMessage
  | StockDispositionMessage
  | ErrorMessage
  | GameOverMessage

// Action payloads for sending to backend
export interface PlaceTileAction {
  action: 'place_tile'
  tile: string
}

export interface FoundChainAction {
  action: 'found_chain'
  chain: ChainName
}

export interface BuyStocksAction {
  action: 'buy_stocks'
  purchases: Partial<Record<ChainName, number>>
}

export interface EndTurnAction {
  action: 'end_turn'
}

export type GameAction =
  | PlaceTileAction
  | FoundChainAction
  | BuyStocksAction
  | EndTurnAction
```

### 3. E2E Test Helpers

**tests/e2e/helpers/api.ts**:
```typescript
import { APIRequestContext } from '@playwright/test'

export interface RoomCreationResult {
  room_code: string
  player_id: string
  session_token: string
}

export async function createRoom(
  request: APIRequestContext,
  playerName: string
): Promise<RoomCreationResult> {
  const response = await request.post('http://localhost:8000/create', {
    form: { player_name: playerName },
  })
  return response.json()
}

export async function joinRoom(
  request: APIRequestContext,
  roomCode: string,
  playerName: string
): Promise<RoomCreationResult> {
  const response = await request.post('http://localhost:8000/join', {
    form: { room_code: roomCode, player_name: playerName },
  })
  return response.json()
}

export async function addBot(
  request: APIRequestContext,
  roomCode: string
): Promise<{ bot_id: string }> {
  const response = await request.post(
    `http://localhost:8000/room/${roomCode}/add-bot`
  )
  return response.json()
}

export async function startGame(
  request: APIRequestContext,
  roomCode: string
): Promise<void> {
  await request.post(`http://localhost:8000/room/${roomCode}/start`)
}

export async function getRoomState(
  request: APIRequestContext,
  roomCode: string
) {
  const response = await request.get(
    `http://localhost:8000/room/${roomCode}/state`
  )
  return response.json()
}
```

**tests/e2e/helpers/websocket.ts**:
```typescript
import { Page } from '@playwright/test'

export async function connectWebSocket(
  page: Page,
  roomCode: string,
  playerId: string,
  token?: string
): Promise<void> {
  const url = token
    ? `ws://localhost:8000/ws/player/${roomCode}/${playerId}?token=${token}`
    : `ws://localhost:8000/ws/player/${roomCode}/${playerId}`

  await page.evaluate((wsUrl) => {
    window.__testWs = new WebSocket(wsUrl)
    window.__testMessages = []
    window.__testWs.onmessage = (e) => {
      window.__testMessages.push(JSON.parse(e.data))
    }
    return new Promise<void>((resolve) => {
      window.__testWs.onopen = () => resolve()
    })
  }, url)
}

export async function waitForMessage(
  page: Page,
  predicate: (msg: unknown) => boolean,
  timeout = 5000
): Promise<unknown> {
  return page.evaluate(
    ({ predicate: predicateFn, timeout: ms }) => {
      return new Promise((resolve, reject) => {
        const check = () => {
          const msg = window.__testMessages.find(predicateFn)
          if (msg) {
            resolve(msg)
            return true
          }
          return false
        }
        if (check()) return

        const interval = setInterval(() => {
          if (check()) clearInterval(interval)
        }, 100)

        setTimeout(() => {
          clearInterval(interval)
          reject(new Error('Timeout waiting for message'))
        }, ms)
      })
    },
    { predicate: predicate.toString(), timeout }
  )
}

export async function sendAction(page: Page, action: unknown): Promise<void> {
  await page.evaluate((act) => {
    window.__testWs.send(JSON.stringify(act))
  }, action)
}

// Declare types for window extensions
declare global {
  interface Window {
    __testWs: WebSocket
    __testMessages: unknown[]
  }
}
```

**tests/e2e/helpers/game.ts**:
```typescript
import { Page, APIRequestContext } from '@playwright/test'
import { createRoom, addBot, startGame } from './api'
import { connectWebSocket, waitForMessage } from './websocket'

export interface GameSetup {
  roomCode: string
  humanPlayer: { id: string; token: string }
  botIds: string[]
}

export async function setupGameWithBots(
  request: APIRequestContext,
  page: Page,
  humanName: string,
  botCount: number
): Promise<GameSetup> {
  // Create room
  const { room_code, player_id, session_token } = await createRoom(
    request,
    humanName
  )

  // Add bots
  const botIds: string[] = []
  for (let i = 0; i < botCount; i++) {
    const { bot_id } = await addBot(request, room_code)
    botIds.push(bot_id)
  }

  // Connect WebSocket
  await connectWebSocket(page, room_code, player_id, session_token)

  // Start game
  await startGame(request, room_code)

  // Wait for initial game state
  await waitForMessage(page, (msg: any) => msg.type === 'game_state')

  return {
    roomCode: room_code,
    humanPlayer: { id: player_id, token: session_token },
    botIds,
  }
}

export async function waitForHumanTurn(page: Page, playerId: string) {
  return waitForMessage(
    page,
    (msg: any) =>
      msg.type === 'game_state' && msg.current_player === playerId,
    10000  // Longer timeout for bot turns
  )
}

export async function waitForPhase(page: Page, phase: string) {
  return waitForMessage(
    page,
    (msg: any) => msg.type === 'game_state' && msg.phase === phase
  )
}
```

### 4. Sample E2E Test

**tests/e2e/bot-game.spec.ts**:
```typescript
import { test, expect } from '@playwright/test'
import { setupGameWithBots, waitForHumanTurn } from './helpers/game'
import { sendAction, waitForMessage } from './helpers/websocket'

test.describe('Bot Game', () => {
  test('can play a game with one human and two bots', async ({
    page,
    request,
  }) => {
    // Setup game with 2 bots
    const { roomCode, humanPlayer } = await setupGameWithBots(
      request,
      page,
      'TestHuman',
      2
    )

    // Wait for our turn (bots may go first)
    const state = await waitForHumanTurn(page, humanPlayer.id) as any

    // Verify we received valid game state
    expect(state.type).toBe('game_state')
    expect(state.your_hand).toBeDefined()
    expect(state.your_hand.length).toBeGreaterThan(0)

    // Play a tile from our hand
    const tileToPlay = state.your_hand[0]
    await sendAction(page, { action: 'place_tile', tile: tileToPlay })

    // Wait for state update
    const newState = await waitForMessage(
      page,
      (msg: any) => msg.type === 'game_state'
    ) as any

    // Verify tile was placed
    expect(newState.board[tileToPlay]).not.toBeNull()
  })

  test('game progresses through bot turns automatically', async ({
    page,
    request,
  }) => {
    const { humanPlayer } = await setupGameWithBots(
      request,
      page,
      'TestHuman',
      2
    )

    // Collect messages for 5 seconds
    await page.waitForTimeout(5000)

    // Check we received multiple game_state updates (bot turns)
    const messages = await page.evaluate(() => window.__testMessages)
    const gameStates = messages.filter((m: any) => m.type === 'game_state')

    // Should have received updates as bots played
    expect(gameStates.length).toBeGreaterThan(1)
  })
})
```

### 5. Integration Test Layer (No Browser)

**tests/integration/websocket.test.ts**:
```typescript
import { describe, it, expect, beforeAll, afterAll } from 'vitest'
import WebSocket from 'ws'

const API_URL = 'http://localhost:8000'
const WS_URL = 'ws://localhost:8000'

describe('WebSocket Integration', () => {
  // Note: Requires backend to be running
  // Run with: npm run test:integration

  it('receives game state after connecting', async () => {
    // Create room via HTTP
    const createRes = await fetch(`${API_URL}/create`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body: 'player_name=IntegrationTest',
    })
    const { room_code, player_id, session_token } = await createRes.json()

    // Connect WebSocket
    const ws = new WebSocket(
      `${WS_URL}/ws/player/${room_code}/${player_id}?token=${session_token}`
    )

    const messages: unknown[] = []
    ws.on('message', (data) => {
      messages.push(JSON.parse(data.toString()))
    })

    await new Promise<void>((resolve) => ws.on('open', resolve))

    // Should receive lobby update
    await new Promise((resolve) => setTimeout(resolve, 500))

    expect(messages.length).toBeGreaterThan(0)
    expect(messages[0]).toHaveProperty('type', 'lobby_update')

    ws.close()
  })
})
```

### 6. Package.json Scripts

Add to **package.json**:
```json
{
  "scripts": {
    "test:integration": "vitest run tests/integration --reporter=verbose",
    "e2e": "playwright test",
    "e2e:headed": "playwright test --headed",
    "e2e:debug": "playwright test --debug"
  }
}
```

### 7. Install Additional Dependencies

```bash
npm install -D ws @types/ws
```

## Testing Requirements

The E2E infrastructure itself should be verified by:

1. **Bot game test passes** - At least one test plays tiles with bots
2. **WebSocket integration test passes** - Direct WebSocket tests work
3. **Types compile** - No TypeScript errors with new API types
4. **CI compatibility** - Tests pass in CI environment

## Verification

```bash
# Start backend manually for development
cd ../backend && uvicorn main:app --port 8000 &

# Run E2E tests (will also start frontend)
npm run e2e

# Run integration tests (requires backend running)
npm run test:integration

# Verify types compile
npm run build
```

## Reference

- [Backend WebSocket API](../../../backend/main.py) - Message schemas
- [Frontend E2E Test Docs](../../../tests/frontend-e2e/README.md)
- [Playwright Multi-Server Config](https://playwright.dev/docs/test-webserver#multiple-web-servers)
