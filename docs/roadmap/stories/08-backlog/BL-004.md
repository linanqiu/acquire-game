# BL-004: Event Log for Room Replay

## Metadata
- **Epic**: Backlog
- **Status**: `not-started`
- **Priority**: `low`
- **Effort**: `L` (2-4 hours)
- **Dependencies**: None

## Context

After generating a room code, we should record every action that happens in the room (tile placements, stock purchases, trades, mergers, etc.) to an event log. This enables:

1. **Testing**: Replay games to reproduce bugs
2. **Analysis**: Study gameplay patterns for AI training
3. **Debugging**: Understand exactly what happened in problem games
4. **Architecture**: Move toward event sourcing where game state is derived from event history

This story likely involves architectural changes to adopt a true event journal pattern.

## Requirements

- Record all game actions as discrete events
- Events should be timestamped and ordered
- Events should contain enough information to replay the game
- Consider storing events persistently (file, database)
- Provide mechanism to replay events to reconstruct game state

## Acceptance Criteria

- [ ] All game actions are recorded as events
- [ ] Events include: player actions, game phase transitions, random events (tile draws)
- [ ] Event log persists beyond server restart (file or DB)
- [ ] Events can be replayed to reconstruct any point in game history
- [ ] Trade actions are included in the log

## Implementation Notes

### Event Types to Capture

- `game_created` - room code, initial config
- `player_joined` - player id, name, is_bot
- `game_started` - initial tile distribution, turn order
- `tile_placed` - player, tile coordinate, result (nothing, found, expand, merge)
- `chain_founded` - player, chain name, founding tiles
- `chain_expanded` - chain name, new tiles
- `merger_started` - acquiring chain, acquired chains, merger tile
- `stock_disposition` - player, chain, sell/trade/keep counts
- `merger_completed` - final chain state
- `stock_purchased` - player, purchases (chain: count)
- `turn_ended` - player, tiles drawn
- `game_ended` - final scores, winner

### Architecture Considerations

**Option A: Append-only log file per room**
- Simple, portable
- One JSON file per room: `logs/{room_code}.jsonl`
- Easy to share for bug reports

**Option B: Event sourcing pattern**
- Game state becomes projection of events
- More architectural change but cleaner long-term
- Enables features like "undo" or "replay from turn N"

**Option C: Database table**
- Queryable, persistent
- Better for analytics across games
- More infrastructure

Recommend starting with Option A (log files) and evolving to Option B if replay becomes important.

### Replay Mechanism

```python
def replay_game(event_log: List[Event]) -> Game:
    game = Game()
    for event in event_log:
        game.apply_event(event)
    return game
```

## Verification

```bash
# After implementation:
# 1. Create and play a game
# 2. Check event log exists for room code
# 3. Verify all actions are recorded
# 4. Use replay function to reconstruct game state
# 5. Compare replayed state to final state
```
